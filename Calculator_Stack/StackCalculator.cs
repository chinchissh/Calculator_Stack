using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator_Stack
{
    // Класс StackCalculator реализует стековый калькулятор.
    //Этот класс представляет стековый калькулятор, который использует стек для выполнения операций.
    //Стековый калькулятор использует стек для вычисления арифметических выражений в постфиксной записи.
    public class StackCalculator
    {
        // Приватное поле stack представляет собой стек для хранения числовых операндов.
        private readonly Stack<double> stack;

        // Приватное поле operationFactory представляет собой фабрику операций, которая будет использоваться для создания операций в калькуляторе.
        private readonly IOperationFactory operationFactory;

        // Конструктор StackCalculator принимает в качестве параметра объект фабрики операций.
        public StackCalculator(IOperationFactory operationFactory)
        {
            // Инициализируем стек и фабрику операций.
            // Объект фабрики операций - это объект, который отвечает за создание экземпляров классов операций в зависимости от символа оператора.
            // Фабричный метод(CreateOperation в данном коде) принимает символ оператора и возвращает соответствующий объект операции(например, сложения, вычитания и т.д.).
            this.stack = new Stack<double>();
            this.operationFactory = operationFactory;
        }

        // Метод Calculate принимает строку с арифметическим выражением и возвращает числовой результат его вычисления.
        // Принимает арифметическое выражение в виде строки, разбивает его на токены и обрабатывает каждый токен. Если токен является числом, он добавляется в стек.
        // Если токен - оператор, создается соответствующий объект операции с использованием фабрики операций и выполняется на стеке.
        // По завершении обработки всех токенов проверяется, что в стеке остался ровно один элемент, который и является результатом вычислений.
        public double Calculate(string expression)
        {
            // Разбиваем выражение на токены (числа и операторы) с помощью пробела в качестве разделителя.
            string[] tokens = expression.Split(' ');

            // Обходим каждый токен в выражении.
            // В контексте данного кода токен представляет собой элемент строки, полученной разбиением арифметического выражения на составные части.
            // Обычно токены включают в себя операторы (+, -, *, /), числа и другие элементы.
            // В данном коде токены разделяются пробелами.
            foreach (var token in tokens)
            {
                // Если токен представляет собой число, добавляем его в стек.
                if (double.TryParse(token, out double operand))
                {
                    stack.Push(operand);
                }
                // Если токен представляет собой оператор, создаем соответствующую операцию и выполняем ее на стеке.
                else
                {
                    // Получаем символ оператора из токена.
                    char operatorSymbol = token[0];

                    // Используем фабрику операций для создания объекта операции.
                    IOperation operation = operationFactory.CreateOperation(operatorSymbol);

                    // Выполняем операцию на стеке.
                    operation.Execute(stack);
                }
            }

            // После обработки всех токенов проверяем, что в стеке остался ровно один элемент - результат вычислений.
            if (stack.Count != 1)
                // Если условие не выполняется, выбрасываем исключение CalculatorException.
                throw new CalculatorException("Некорректное выражение.");

            // Возвращаем результат вычислений, находящийся на вершине стека.
            // После обработки всех токенов, результат вычисления находится в верхней части стека.
            // Если в стеке остается ровно один элемент, это и есть итоговый результат.
            return stack.Pop();
        }
    }
}
